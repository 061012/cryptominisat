%\documentclass[runningheads]{llncs}
\documentclass[final]{ieee}

\usepackage{microtype} %This gives MUCH better PDF results!
%\usepackage[active]{srcltx} %DVI search
\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
\usepackage{fnbreak} %warn for split footnotes
\usepackage{url}
%\usepackage{qtree} %for drawing trees
%\usepackage{fancybox} % if we need rounded corners
%\usepackage{pict2e} % large circles can be drawn
%\usepackage{courier} %for using courier in texttt{}
%\usepackage{nth} %allows to \nth{4} to make 1st 2nd, etc.
%\usepackage{subfigure} %allows to have side-by-side figures
%\usepackage{booktabs} %nice tables
%\usepackage{multirow} %allow multiple cells with rows in tabular
\usepackage[utf8]{inputenc} % allows to write Faugere correctly
\usepackage[bookmarks=true, citecolor=black, linkcolor=black, colorlinks=true]{hyperref} %For nicer electronic version
%\usepackage{fancyvrb} % fancy verbatim package, used with \begin{Verbatim} instead of \begin{verbatim}
\hypersetup{
pdfauthor = {Mate Soos},
pdftitle = {CryptoMiniSat 2.4},
pdfsubject = {SAT Race 2010},
pdfkeywords = {SAT Solver, DPLL},
pdfcreator = {PdfLaTeX with hyperref package},
pdfproducer = {PdfLaTex}}
%\usepackage{butterma}

%\usepackage{pstricks}
\usepackage{graphicx,epsfig,xcolor}
\usepackage[algoruled, linesnumbered, lined]{algorithm2e} %algorithms

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   to generate the online version of the accepted paper
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\usepackage{butterma} 
%\idline{O.~Kullmann (Eds.): Springer, LNCS 5584}
%\setcounter{page}{244}
%\renewcommand{\year}{2009}
%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   to generate the online version of the accepted paper
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\thispagestyle{electronic}
%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{CryptoMiniSat 2.4}
\author{Mate Soos}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}

% \begin{abstract}
% In this paper, we describe CryptoMiniSat, a SAT solver developed from MiniSat that aims to be a full-featured SAT solver with many effective techniques. It has xor-clause handling, regular clause cleaning, problem simplification, subproblem-detection, variable replacement, among many other features.
% \end{abstract}

\section{Introduction}
%%%%%%%%%%
SAT solvers have recently been enjoying a boom in multiple application areas, notably cryptography. It has been shown in multiple papers \cite{DBLP:conf/ima/CourtoisB07,BiviumWithSATsolvers,DBLP:conf/sat/SoosNC09} that SAT solvers are indeed a viable technique in algebraic cryptanalysis to both analyse and potentially break stream or block ciphers. Furthermore, SAT solvers are used in a variety of applications, ranging from software verification to electronic design automation.

In this paper we present the feature-set of CryptoMiniSat, a modern SAT Solver that aims to unify the advantages of SatELite \cite{DBLP:conf/sat/EenB05}, PrecoSat \cite{precosat}, GLUCOSE \cite{glucose} and MiniSat \cite{EenS03MiniSat} with the xor-clause handling of version 1 of CryptoMiniSat \cite{DBLP:conf/sat/SoosNC09} to create a formula that can solve many types of different problem instances under reasonable time.

% The rest of this paper is structured as follows. In Sect. \ref{sect:background} we give some background on DPLL-based SAT solvers. Then, in Sect. \ref{sect:features} we present the features offered by CryptoMiniSat. In Sect. \ref{sect:results} we shortly describe the results possible with the use of the tool. Finally, in Sect. \ref{sect:conclusions} we conclude this paper.

% \section{Background}
% Satisfiability solvers are complex mathematical algorithms used to decide whether a set of constraints have a solution or not. This paper only discusses the well-known conjunctive normal form (CNF) constraint type. The CNF formula $\varphi$ on $n$ binary variables $x_1,\ldots, x_n$, is a conjunction (\texttt{and}-ing) of $m$ clauses $\omega_1,\ldots, \omega_m$ each of which is the disjunction (\texttt{or}-ing) of literals, where a literal is the occurrence of a variable e.g. $x_1$ or its complement, $\neg x_1$.
% 
% In this paper, we focus on solvers that use the DPLL algorithm. The DPLL procedure is a backtracking, depth-first search algorithm that tries to find a variable assignment that satisfies a system of clauses. The algorithm branches on a variable by assigning it to \texttt{true} or \texttt{false} and examining whether the value of other variables depend on this branching. If they do, the affected variables are assigned to the indicated value and the search continues until no more assignments can be made. During this period, called \emph{propagation}, a clause may become unsatisfiable, as all of its literals have been assigned to \texttt{false}. If such a \emph{conflict} is encountered, a \emph{learnt clause} is generated that captures the wrong variable assignments leading to the conflict. The topmost branching allowed by the learnt clause is reversed and the algorithm starts again. The learnt clauses trim the search tree, reducing the overall time to finish the search. Eventually, either a satisfiable assignment is found or the search tree is exhausted without a solution being found and the problem is determined to be unsatisfiable.
% 
\section{Features}
CryptoMiniSat is a DPLL-based SAT solver developed from MiniSat. The following list of non-exhaustive features are offered by CryptoMiniSat relative to the original ``core'' MiniSat.

\subsection{Xor clauses}
XOR clauses are extracted at the beginning of the solving. They are subsequently treated differently. They have their own watchlists, their own propagation mechanism, and their own subsumption algorithm. This should mean that they are handled faster in most scenarios.

\subsection{Binary xor clauses}
Binary xor clauses are handled specially. Firstly, they are reguarly searched for using a special heuristic. Secondly, a forest structure is built from them, indicating which variable is equi- or antivalent with which variable. The top of the trees are reguarly replaced with those lower in the tree, reducing the number of clauses and variables in the problem, and usually leading to variable assignements (and possibly even more binary xor clauses).

\subsection{Binary xor clause finding through regular XOR-ing of xor clauses}
As per the PhD Thesis of Heule \cite{Heule-phd}, xor clauses are regularly XOR-ed with one another to obtain different XOR clauses. However, contrary to that present in the paper, the smaller XOR-s are only acted upon if they are binary. In this case, they are added to the forest of equi- and antivalences, and replaced with one another at a later time, according to a heuristic.

\subsection{Phase calculation, saving and random flipping}
Default phase is calculated for each variable according to the Jeroslow and Wang \cite{DBLP:journals/amai/JeroslowW90} heuristic. The phases are saved, according to Pipatsrisawat and Darwiche \cite{DBLP:conf/sat/PipatsrisawatD07}. The phase, however, is randomly flipped at intervals that is determined by the problem. The average branch depth is measured, and with P(1/avgBranchDepth), the current phase is flipped. According to our experience, this helps in exploring new places in the search space.

% \subsubsection*{Random seach bursts}
% At certain points in the search, random search busrsts are carried out for 500 conflicts. During these bursts, the variables are assigned and picked very randomly. The phase, variable and clause activities are saved and restored before and after the search bursts. According to our experience, these bursts help finding a solution faster.

\subsection{Automatic detection of cryptographic and industrial instances}
Industrial and cryptographic instances are very different. They need different restart strategies and they need different learnt clause activity statistics. We try to detect which problem belongs to which family, and use GLUCOSE-style learnt clause heuristics \cite{DBLP:conf/ijcai/AudemardS09} or MiniSat-stlye learnt clause activity accordingly. We also switch the restart type from dynamic to static and vica-versa. The detection is based on the percentage of xor clauses and the stability of variable activity. Either of the two is too high, the problem is deemed to be cryptographic. The stability of variable activity is measured through saving of the top 100 variables, and comparing them with the next restart's top 100 variables. This is done for 5 restarts, and at the end, the decision is made. The detection routine is run regularly, to detect whether the problem has changed enough to switch from one type to the other.

\subsection{Variable elimination, clause subsumption and clause strenghtening}
SatELite-type variable elimination, clause subsumption and clause strengthening is regularly performed. The occurance lists are, however, not updated all the time such as the case with other solvers. Instead, occurances are calculated on per-use basis. The number of variable elimination cycles, clause subsumption cycles and clause strenghtening cycles are limited each time the simplification is done such as to avoid the routine taking overly large amounts of time.

\subsection{On-the-fly clause improvement}
Since the occurance lists are not updated all the time, the only way to carry out sumbsumption is the algorithm by Han and Somenzi \cite{DBLP:conf/sat/HanS09}. This lightweight subsumption-check is carried out every time a conflict analysis is done.

\subsection{Binary clause propagation}
Binary clauses are in a separate watchlist, as per GLUCOSE \cite{glucose}. They are fully propagated before other clauses are propagated. The propagation order is: binary clauses, regular clauses, xor clauses. As per PrecoSat \cite{precosat}, the binary clauses are always fully propagated, regardless if a conflict has been found earlier. The conflict analysis routine is then called on the last conflicting binary clause.

\subsection{32-bit pointers on 64-bit architectures under Linux}
64-bit pointers are well-known to slow down the solving of SAT solvers, due to the extra memory and thus cache space occupied by them when going through the watchlists in the propagation phase. This limitation means that all code has to be compiled as 32-bit code, which means that extra registers and instructions provided by modern 64-bit architectures is lost. We coutner this phenomenon with small pointers. Since the memory used by SAT solvers is rarely more than 4GB, the pointers rarely contain more than 32 bit real information. We extract this information, and only store these 32 bits. Unfortunately, our technique leads to segmentation fault when compiled with MSVC under Windows, and so it is not used in that case.

% \subsubsection*{Hyper-binary resolution}
% Hyper-binary resolution is used. Though it is relatively fast and can usually find many binary clauses, we have found that adding all possible binary clauses doesn't actually speed up the solving. This might be the result of the problem of ternary resolvents, explained in \cite[Sect. 4.3.2]{Heule-phd}, though this needs to be further investigated. Every binary clause we find, we try to backward subsume other clauses with it, and if it subsumes other clauses, those are removed, and the binary clause is added. Otherwise, the binary clause is discarded.

\subsection{Clause cleaning}
Clauses are regularly removed that have at least one of their literals assigned to \texttt{true}. Contrary to 'core' MiniSat, we also remove \texttt{false} literals from clauses, shortening them. Interestingly, this does not need these clauses to be re-attached, as \texttt{false} literals are not in the watchlists --- of if they are, the clause is satisfied, and can be fully removed.

% \subsubsection*{Preliminary blocked clause elimination}
% Blocked clauses have been shown to be an interesting approach to reduce the number of constraints by Biere and Jarvisalo \cite{DBLP:conf/tacas/JarvisaloBH10}. Although full blocked clause elimination is not carried out by CryptoMiniSat since the reconstruction of the solution is non-trivial after removal, blocked clause elimination is used in the sense that if all clauses that contain literal $l$ can be eliminated on $l$, then the variable var($l$) is removed, along with all associated clauses. It is later re-introduced to extend the solution, as per SatELite.

\subsection{Subproblem detection and handling}
Problems can sometimes contain multiple fully distinct subproblems. We build a connection graph between clauses, and treat graph components as distinct problems. These subproblems are solved with subsolvers, their solutions are saved, and finally added at the solution extension phase. If any of the subproblems are UNSAT, then the whole problem is UNSAT. Interestingly, it is a good idea to check for subproblems regularly. As problems are solved, variables are sometimes assigned at decision level zero, disconnecting the graph into distinct components. We regularly check for such occurances, and solve the subproblems as described.

\subsection{Xor clause subsumption}
Xor clauses can be subsumed similarly to normal clauses. Since xor clauses represent many regular clauses, doing the subsumption natively saves significant time.

\subsection{Dependent variable removal}
Dependent variables , as per \cite{Heule-phd} are removed along with their corresponding xor clause. Dependent variables are varibles that appear nowhere else but in exactly one xor clause. Since that xor clause can always be satisfied by a correct value of the dependent variable, the xor clause can be removed without further ado, and reintroduced during solution extension as per SatELite. This removes a constraint and a varible from the problem. Note that this variable could not have been removed as part of pure literal elimination. However, interestingly, blocked clause elimination (BCE) removes these clauses and corresponding variable(s). This has not been noted by Biere and Jarvisalo in \cite{DBLP:conf/tacas/JarvisaloBH10}, but shows the effectiveness of their method.

\subsection{Failed variable probing}
Variables are tried to be branched both to \texttt{true} and \texttt{false} at regular intervals. If any of the branches fails (conflict is returned), that variable is assigned to the other branching. Otherwise, the assignments of both are saved and compared with one another. If they contain a common subset, that variable is assigned. A similar algorithm was used in SatELite, called assymetric branching. An interesting addition to this is the method by Li \cite{DBLP:journals/dam/Li03}, where binary XOR clauses are found in the same way that common subset of assignents are found. After branching to \texttt{true} we note the number of xor clauses that haved been shrinked to the size of 2. Then, we branch to \texttt{false}, and we again note if any xor clauses have shrinked to the size of 2. If any binary XOR-s of these two sets match, that xor clause can be learnt, effectively replacing one variable with (possibly inverse of) the other.
 
\bibliographystyle{splncs}
\bibliography{sigproc}

\vfill
\pagebreak

\end{document}
